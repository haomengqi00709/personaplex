<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PersonaPlex å®æ—¶ç¿»è¯‘</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
        }
        .container {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
        }
        button {
            padding: 10px 20px;
            margin: 10px 5px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
        }
        button:hover {
            background: #45a049;
        }
        button.recording {
            background: #f44336;
        }
        select {
            padding: 8px;
            margin: 10px 5px;
            font-size: 14px;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            background: #e0e0e0;
            border-radius: 5px;
        }
        .debug-panel {
            margin: 20px 0;
            padding: 15px;
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        .debug-panel h3 {
            margin-top: 0;
            color: #333;
        }
        .debug-item {
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid #eee;
        }
        .debug-label {
            font-weight: bold;
            color: #666;
            display: inline-block;
            width: 150px;
        }
        .debug-value {
            color: #000;
        }
        .debug-error {
            color: #d32f2f;
        }
        .debug-success {
            color: #388e3c;
        }
        .debug-warning {
            color: #f57c00;
        }
    </style>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>PersonaPlex å®æ—¶å¯¹è¯</h1>
        
        <div class="status" id="status">çŠ¶æ€: æœªè¿æ¥</div>
        <div class="status" id="volumeStatus" style="display: none;">
            éŸ³é‡: <span id="volumeValue">0.0000</span> | 
            æœ€å¤§éŸ³é‡: <span id="maxVolumeValue">0.0000</span> | 
            çŠ¶æ€: <span id="audioStatus">ç­‰å¾…ä¸­...</span>
        </div>
        
        <div>
            <button id="loadModelBtn">åŠ è½½æ¨¡å‹</button>
            <span id="modelStatus"></span>
        </div>
        
        <div style="margin: 20px 0;">
            <label>æºè¯­è¨€:</label>
            <select id="sourceLang">
                <option value="en">è‹±è¯­</option>
                <option value="zh">ä¸­æ–‡</option>
            </select>
            
            <label>ç›®æ ‡è¯­è¨€:</label>
            <select id="targetLang">
                <option value="zh">ä¸­æ–‡</option>
                <option value="en">è‹±è¯­</option>
            </select>
        </div>
        
        <div style="margin: 10px 0;">
            <label>é™éŸ³é˜ˆå€¼:</label>
            <input type="range" id="silenceThreshold" min="0.001" max="0.1" step="0.001" value="0.005" 
                   oninput="document.getElementById('thresholdValue').textContent = this.value">
            <span id="thresholdValue">0.005</span>
            <small style="display: block; color: #666;">å€¼è¶Šå°è¶Šæ•æ„Ÿï¼Œå»ºè®® 0.003-0.01ã€‚è§‚å¯Ÿä¸Šæ–¹"æœ€å¤§éŸ³é‡"æ¥è°ƒæ•´</small>
        </div>
        
        <div>
            <button id="recordBtn">ğŸ™ï¸ å¼€å§‹å½•éŸ³</button>
        </div>
        
        <div id="output" style="margin-top: 20px; padding: 10px; background: white; border-radius: 5px; min-height: 100px;">
            <p>å¯¹è¯å“åº”å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ...</p>
        </div>
        
        <div class="debug-panel">
            <h3>ğŸ” è°ƒè¯•ä¿¡æ¯</h3>
            <div id="debugInfo">
                <div class="debug-item">
                    <span class="debug-label">è¿æ¥çŠ¶æ€:</span>
                    <span class="debug-value" id="debugConnection">æœªè¿æ¥</span>
                </div>
                <div class="debug-item">
                    <span class="debug-label">æ¨¡å‹çŠ¶æ€:</span>
                    <span class="debug-value" id="debugModel">æœªåŠ è½½</span>
                </div>
                <div class="debug-item">
                    <span class="debug-label">è¯·æ±‚è®¡æ•°:</span>
                    <span class="debug-value" id="debugRequests">0</span>
                </div>
                <div class="debug-item">
                    <span class="debug-label">æˆåŠŸ/å¤±è´¥:</span>
                    <span class="debug-value" id="debugSuccessFail">0 / 0</span>
                </div>
                <div class="debug-item">
                    <span class="debug-label">å¹³å‡å¤„ç†æ—¶é—´:</span>
                    <span class="debug-value" id="debugAvgTime">0.00s</span>
                </div>
                <div class="debug-item">
                    <span class="debug-label">GPU å†…å­˜:</span>
                    <span class="debug-value" id="debugMemory">-</span>
                </div>
                <div class="debug-item">
                    <span class="debug-label">é˜Ÿåˆ—çŠ¶æ€:</span>
                    <span class="debug-value" id="debugQueue">-</span>
                </div>
                <div class="debug-item">
                    <span class="debug-label">æœ€åè¯·æ±‚æ—¶é—´:</span>
                    <span class="debug-value" id="debugLastRequest">-</span>
                </div>
                <div class="debug-item">
                    <span class="debug-label">æœ€åå¤„ç†æ—¶é—´:</span>
                    <span class="debug-value" id="debugLastProcess">-</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // é…ç½® Socket.IO è¿æ¥ï¼Œå‡å°‘ä¸å¿…è¦çš„é‡è¿
        const socket = io({
            reconnection: true,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            reconnectionAttempts: 5,
            timeout: 20000,
            transports: ['websocket', 'polling']
        });
        let isRecording = false;
        let audioContext = null;
        let processor = null;
        let stream = null;
        let audioChunks = [];
        let sendInterval = null;
        let silenceThreshold = 0.005; // é™éŸ³é˜ˆå€¼ï¼ˆé™ä½é»˜è®¤å€¼ï¼Œæ›´æ•æ„Ÿï¼‰
        let minAudioLength = 0.3; // æœ€å°éŸ³é¢‘é•¿åº¦ï¼ˆç§’ï¼‰ï¼Œé™ä½åˆ°0.3ç§’
        let maxSilenceFrames = 30; // è¿ç»­é™éŸ³å¸§æ•°ï¼Œå¢åŠ è¿™ä¸ªå€¼
        let currentRMS = 0; // å½“å‰éŸ³é‡
        let maxRMS = 0; // æœ€å¤§éŸ³é‡ï¼ˆç”¨äºæ˜¾ç¤ºï¼‰
        let consecutiveSilenceCount = 0; // è¿ç»­é™éŸ³è®¡æ•°
        let silenceThresholdFrames = 15; // è¿ç»­é™éŸ³å¤šå°‘å¸§åè®¤ä¸ºè¯´è¯ç»“æŸï¼ˆçº¦0.5ç§’ï¼Œ24000/4096*15ï¼‰
        let hasSpeechInBuffer = false; // ç¼“å†²åŒºä¸­æ˜¯å¦æœ‰è¯­éŸ³

        // è®¡ç®—éŸ³é¢‘éŸ³é‡ï¼ˆRMSï¼‰
        function calculateRMS(audioData) {
            let sum = 0;
            for (let i = 0; i < audioData.length; i++) {
                sum += audioData[i] * audioData[i];
            }
            return Math.sqrt(sum / audioData.length);
        }

        // æ£€æµ‹æ˜¯å¦æœ‰æœ‰æ•ˆè¯­éŸ³
        function hasValidSpeech(audioData) {
            const rms = calculateRMS(audioData);
            return rms > silenceThreshold;
        }

        // Socket.IO è¿æ¥
        socket.on('connect', () => {
            const time = new Date().toLocaleTimeString();
            console.log(`âœ“ [DEBUG] WebSocket å·²è¿æ¥ | æ—¶é—´: ${time} | Socket ID: ${socket.id}`);
            document.getElementById('status').textContent = 'çŠ¶æ€: å·²è¿æ¥';
            document.getElementById('status').style.color = 'green';
            updateDebugInfo();
        });

        socket.on('disconnect', (reason) => {
            const time = new Date().toLocaleTimeString();
            console.log(`âœ— [DEBUG] WebSocket å·²æ–­å¼€ | æ—¶é—´: ${time} | åŸå› : ${reason}`);
            document.getElementById('status').textContent = `çŠ¶æ€: æœªè¿æ¥ (${reason})`;
            document.getElementById('status').style.color = 'red';
            updateDebugInfo();
        });
        
        socket.on('connect_error', (error) => {
            console.error('âœ— [DEBUG] WebSocket è¿æ¥é”™è¯¯:', error);
        });
        
        socket.on('reconnect', (attemptNumber) => {
            const time = new Date().toLocaleTimeString();
            console.log(`â†» [DEBUG] WebSocket é‡è¿æˆåŠŸ | æ—¶é—´: ${time} | å°è¯•æ¬¡æ•°: ${attemptNumber}`);
        });
        
        socket.on('reconnect_attempt', (attemptNumber) => {
            console.log(`â†» [DEBUG] æ­£åœ¨å°è¯•é‡è¿... | å°è¯•æ¬¡æ•°: ${attemptNumber}`);
        });
        
        socket.on('reconnect_failed', () => {
            console.error('âœ— [DEBUG] WebSocket é‡è¿å¤±è´¥');
        });

        socket.on('translated_audio', (data) => {
            // æ’­æ”¾å¯¹è¯å“åº”éŸ³é¢‘
            console.log('âœ“ [DEBUG] æ”¶åˆ°å¯¹è¯å“åº”');
            document.getElementById('audioStatus').textContent = 'æ”¶åˆ°å›å¤';
            document.getElementById('audioStatus').style.color = 'green';
            updateDebugInfo(); // æ›´æ–°è°ƒè¯•ä¿¡æ¯
            const audio = new Audio('data:audio/wav;base64,' + data.audio);
            audio.play();
        });
        
        socket.on('audio_error', (data) => {
            console.error('âœ— [DEBUG] éŸ³é¢‘é”™è¯¯:', data.error);
            document.getElementById('audioStatus').textContent = 'é”™è¯¯: ' + data.error;
            document.getElementById('audioStatus').style.color = 'red';
            updateDebugInfo(); // æ›´æ–°è°ƒè¯•ä¿¡æ¯
        });
        
        // æ›´æ–°è°ƒè¯•ä¿¡æ¯
        async function updateDebugInfo() {
            try {
                const response = await fetch('/api/status');
                const status = await response.json();
                
                document.getElementById('debugConnection').textContent = 
                    status.model_loaded ? 'å·²è¿æ¥' : 'æœªè¿æ¥';
                document.getElementById('debugConnection').className = 
                    status.model_loaded ? 'debug-value debug-success' : 'debug-value debug-error';
                
                document.getElementById('debugModel').textContent = 
                    status.model_loaded ? 'å·²åŠ è½½' : 'æœªåŠ è½½';
                document.getElementById('debugModel').className = 
                    status.model_loaded ? 'debug-value debug-success' : 'debug-value debug-error';
                
                if (status.debug_stats) {
                    document.getElementById('debugRequests').textContent = 
                        status.debug_stats.total_requests || 0;
                    document.getElementById('debugSuccessFail').textContent = 
                        `${status.debug_stats.successful_requests || 0} / ${status.debug_stats.failed_requests || 0}`;
                    document.getElementById('debugSuccessFail').className = 
                        status.debug_stats.failed_requests > 0 ? 'debug-value debug-warning' : 'debug-value debug-success';
                    
                    document.getElementById('debugAvgTime').textContent = 
                        (status.debug_stats.avg_processing_time || 0).toFixed(2) + 's';
                    
                    if (status.debug_stats.memory_info) {
                        const mem = status.debug_stats.memory_info;
                        document.getElementById('debugMemory').textContent = 
                            `${mem.allocated_mb || 0}MB / ${mem.reserved_mb || 0}MB (å¯ç”¨: ${mem.free_mb || 0}MB)`;
                    }
                    
                    document.getElementById('debugLastRequest').textContent = 
                        status.debug_stats.last_request_time || '-';
                    document.getElementById('debugLastProcess').textContent = 
                        (status.debug_stats.last_processing_time || 0).toFixed(2) + 's';
                }
                
                document.getElementById('debugQueue').textContent = 
                    `é˜Ÿåˆ—: ${status.queue_size || 0} | å¤„ç†ä¸­: ${status.is_processing ? 'æ˜¯' : 'å¦'}`;
                document.getElementById('debugQueue').className = 
                    status.is_processing ? 'debug-value debug-warning' : 'debug-value';
            } catch (error) {
                console.error('è·å–è°ƒè¯•ä¿¡æ¯å¤±è´¥:', error);
            }
        }
        
        // å®šæœŸæ›´æ–°è°ƒè¯•ä¿¡æ¯
        setInterval(updateDebugInfo, 2000); // æ¯2ç§’æ›´æ–°ä¸€æ¬¡

        // åŠ è½½æ¨¡å‹
        async function loadModel() {
            try {
                const response = await fetch('/api/load_model', { method: 'POST' });
                const result = await response.json();
                document.getElementById('modelStatus').textContent = result.message;
            } catch (error) {
                console.error('åŠ è½½æ¨¡å‹å¤±è´¥:', error);
            }
        }

        // å¼€å§‹å½•éŸ³
        async function startRecording() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
                const source = audioContext.createMediaStreamSource(stream);
                processor = audioContext.createScriptProcessor(4096, 1, 1);
                
                audioChunks = [];
                
                processor.onaudioprocess = (e) => {
                    const inputData = e.inputBuffer.getChannelData(0);
                    // è®¡ç®—éŸ³é‡
                    currentRMS = calculateRMS(inputData);
                    if (currentRMS > maxRMS) {
                        maxRMS = currentRMS;
                    }
                    
                    // æ£€æµ‹æ˜¯å¦æœ‰è¯­éŸ³
                    const hasSpeech = currentRMS > silenceThreshold;
                    
                    // æ›´æ–°æ˜¾ç¤º
                    if (isRecording) {
                        document.getElementById('volumeValue').textContent = currentRMS.toFixed(4);
                        document.getElementById('maxVolumeValue').textContent = maxRMS.toFixed(4);
                        document.getElementById('audioStatus').textContent = hasSpeech ? 'æ£€æµ‹åˆ°è¯­éŸ³' : 'é™éŸ³';
                        document.getElementById('audioStatus').style.color = hasSpeech ? 'green' : 'gray';
                    }
                    
                    // æ”¶é›†æ‰€æœ‰éŸ³é¢‘å—
                    audioChunks.push(new Float32Array(inputData));
                    
                    // è·Ÿè¸ªæ˜¯å¦æœ‰è¯­éŸ³
                    if (hasSpeech) {
                        hasSpeechInBuffer = true;
                        consecutiveSilenceCount = 0;
                    } else {
                        consecutiveSilenceCount++;
                    }
                    
                    // é™åˆ¶éŸ³é¢‘å—æ•°é‡ï¼Œé¿å…å†…å­˜æº¢å‡ºï¼ˆå¢åŠ åˆ°200ï¼Œå…è®¸æ›´é•¿çš„å¥å­ï¼‰
                    if (audioChunks.length > 200) {
                        audioChunks.shift(); // ç§»é™¤æœ€æ—§çš„å—
                    }
                };
                
                source.connect(processor);
                processor.connect(audioContext.destination);
                
                // æ™ºèƒ½å‘é€ï¼šæ£€æµ‹åˆ°é™éŸ³åå‘é€ï¼Œè€Œä¸æ˜¯å›ºå®šæ—¶é—´é—´éš”
                sendInterval = setInterval(() => {
                    if (audioChunks.length > 0) {
                        // åˆå¹¶éŸ³é¢‘å—
                        const totalLength = audioChunks.reduce((sum, chunk) => sum + chunk.length, 0);
                        const merged = new Float32Array(totalLength);
                        let offset = 0;
                        for (const chunk of audioChunks) {
                            merged.set(chunk, offset);
                            offset += chunk.length;
                        }
                        
                        // æ£€æŸ¥éŸ³é¢‘é•¿åº¦å’Œæ˜¯å¦æœ‰æœ‰æ•ˆè¯­éŸ³
                        const audioDuration = merged.length / 24000; // ç§’
                        const rms = calculateRMS(merged);
                        const hasSpeech = rms > silenceThreshold;
                        
                        // å¦‚æœæ£€æµ‹åˆ°è¿ç»­é™éŸ³ï¼Œä¸”ä¹‹å‰æœ‰è¯­éŸ³ï¼Œåˆ™å‘é€ï¼ˆç­‰å¾…ç”¨æˆ·è¯´å®Œï¼‰
                        const shouldSend = hasSpeechInBuffer && 
                                         consecutiveSilenceCount >= silenceThresholdFrames && 
                                         audioDuration >= minAudioLength;
                        
                        // æˆ–è€…éŸ³é¢‘å¤ªé•¿ï¼ˆè¶…è¿‡8ç§’ï¼‰ï¼Œå¼ºåˆ¶å‘é€ï¼ˆé¿å…å†…å­˜é—®é¢˜ï¼‰
                        const forceSend = audioDuration >= 8.0 && hasSpeech;
                        
                        // åªåœ¨æœ‰æœ‰æ•ˆè¯­éŸ³ä¸”æ»¡è¶³å‘é€æ¡ä»¶æ—¶æ‰å‘é€
                        if ((shouldSend || forceSend) && audioDuration >= minAudioLength) {
                            // è½¬æ¢ä¸º WAV
                            const wavBuffer = audioBufferToWav({
                                numberOfChannels: 1,
                                length: merged.length,
                                sampleRate: 24000,
                                getChannelData: (ch) => {
                                    if (ch === 0) return merged;
                                    return new Float32Array(merged.length);
                                }
                            });
                            
                            // è½¬æ¢ä¸ºæ•°ç»„å¹¶å‘é€
                            const uint8Array = new Uint8Array(wavBuffer);
                            const audioArray = Array.from(uint8Array);
                            
                            // éªŒè¯æ–‡ä»¶å¤´
                            if (audioArray.length >= 4) {
                                const headerStr = String.fromCharCode(
                                    audioArray[0], audioArray[1], audioArray[2], audioArray[3]
                                );
                                
                                if (headerStr === 'RIFF') {
                                    const sourceLang = document.getElementById('sourceLang').value;
                                    const targetLang = document.getElementById('targetLang').value;
                                    
                                    const sendTime = new Date().toLocaleTimeString();
                                    console.log(`âœ“ [DEBUG] å‘é€éŸ³é¢‘æ•°æ® | æ—¶é—´: ${sendTime} | RMS: ${rms.toFixed(4)} | é•¿åº¦: ${audioDuration.toFixed(2)}ç§’ | å¤§å°: ${audioArray.length} å­—èŠ‚`);
                                    document.getElementById('audioStatus').textContent = 'å‘é€ä¸­...';
                                    document.getElementById('audioStatus').style.color = 'blue';
                                    
                                    socket.emit('audio_chunk', {
                                        audio: audioArray,
                                        source_lang: sourceLang,
                                        target_lang: targetLang
                                    });
                                    
                                    // æ›´æ–°è°ƒè¯•ä¿¡æ¯
                                    setTimeout(updateDebugInfo, 500);
                                    
                                    // å‘é€åé‡ç½®çŠ¶æ€
                                    audioChunks = [];
                                    hasSpeechInBuffer = false;
                                    consecutiveSilenceCount = 0;
                                } else {
                                    console.error('éŸ³é¢‘æ–‡ä»¶å¤´æ— æ•ˆ:', headerStr);
                                }
                            }
                        } else {
                            // å¦‚æœè¿˜åœ¨è¯´è¯ï¼Œä¸å‘é€ï¼Œç»§ç»­æ”¶é›†
                            if (hasSpeech) {
                                // ç»§ç»­æ”¶é›†ï¼Œä¸å‘é€
                            } else if (!hasSpeechInBuffer) {
                                // æ²¡æœ‰è¯­éŸ³ï¼Œæ¸…ç©ºç¼“å†²åŒºï¼ˆé¿å…ç§¯ç´¯å¤ªå¤šé™éŸ³ï¼‰
                                if (audioChunks.length > 10) {
                                    audioChunks = audioChunks.slice(-5);
                                }
                            }
                        }
                    }
                }, 500); // æ›´é¢‘ç¹åœ°æ£€æŸ¥ï¼ˆ500msï¼‰ï¼Œä½†åªåœ¨æ»¡è¶³æ¡ä»¶æ—¶å‘é€
                
                isRecording = true;
                maxRMS = 0; // é‡ç½®æœ€å¤§éŸ³é‡
                document.getElementById('recordBtn').textContent = 'â¹ï¸ åœæ­¢å½•éŸ³';
                document.getElementById('recordBtn').classList.add('recording');
                document.getElementById('volumeStatus').style.display = 'block';
                
            } catch (error) {
                console.error('å½•éŸ³å¤±è´¥:', error);
                alert('æ— æ³•è®¿é—®éº¦å…‹é£: ' + error.message);
            }
        }

        // åœæ­¢å½•éŸ³
        function stopRecording() {
            if (isRecording) {
                if (processor) processor.disconnect();
                if (stream) stream.getTracks().forEach(track => track.stop());
                if (audioContext) audioContext.close();
                if (sendInterval) clearInterval(sendInterval);
                
                isRecording = false;
                document.getElementById('recordBtn').textContent = 'ğŸ™ï¸ å¼€å§‹å½•éŸ³';
                document.getElementById('recordBtn').classList.remove('recording');
                document.getElementById('volumeStatus').style.display = 'none';
                document.getElementById('audioStatus').textContent = 'å·²åœæ­¢';
            }
        }

        // å°†éŸ³é¢‘æ•°æ®è½¬æ¢ä¸º WAV
        function audioBufferToWav(buffer) {
            const numOfChan = buffer.numberOfChannels || 1;
            const sampleRate = buffer.sampleRate || 24000;
            const length = buffer.length;
            const dataLength = length * numOfChan * 2;
            const arrayBuffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(arrayBuffer);
            let pos = 0;

            const setUint16 = (data) => {
                view.setUint16(pos, data, true);
                pos += 2;
            };
            const setUint32 = (data) => {
                view.setUint32(pos, data, true);
                pos += 4;
            };

            // WAV æ–‡ä»¶å¤´
            setUint32(0x46464952); // "RIFF"
            setUint32(36 + dataLength);
            setUint32(0x45564157); // "WAVE"
            setUint32(0x20746d66); // "fmt "
            setUint32(16);
            setUint16(1); // PCM
            setUint16(numOfChan);
            setUint32(sampleRate);
            setUint32(sampleRate * 2 * numOfChan);
            setUint16(numOfChan * 2);
            setUint16(16);
            setUint32(0x61746164); // "data"
            setUint32(dataLength);

            // å†™å…¥ PCM æ•°æ®
            const channelData = buffer.getChannelData(0);
            for (let i = 0; i < length; i++) {
                let sample = Math.max(-1, Math.min(1, channelData[i]));
                sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                view.setInt16(pos, sample, true);
                pos += 2;
            }

            return arrayBuffer;
        }

        // äº‹ä»¶ç›‘å¬
        document.getElementById('loadModelBtn').addEventListener('click', loadModel);
        document.getElementById('recordBtn').addEventListener('click', () => {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        });
        
        // æ›´æ–°é™éŸ³é˜ˆå€¼
        document.getElementById('silenceThreshold').addEventListener('input', (e) => {
            silenceThreshold = parseFloat(e.target.value);
            document.getElementById('thresholdValue').textContent = silenceThreshold.toFixed(3);
        });
    </script>
</body>
</html>
